# C言語　基礎入門
## **1. 演算と変数**
### <u>header file (ヘッダーファイル)</u>
    #include <stdio.h>
- header file を読み込む時に用いる宣言
- **.h** は C言語の heder file の拡張子
- 基本的に C言語の program はこの宣言から始まる

### <u>関数</u>
    # メイン関数
    void main()

    # 正式に関数
    pritnf("helloworld\n");
- **main( ) メイン関数**は program の本体
  - main() の中に処理を記述する事により実行される
  - 処理の中身は　"{ "および" }" で囲まれる

- **printf** などの命令のことを、C言語では正式に**関数（かんすう）**と呼ぶ
  - 関数には元から備えられたモノ, user によって後付けされたもの２種類ある

- 処理末尾には **; (セミコロン)**
  - それぞれの処理を区切る必要がある

- **\n** は改行を意味する(mac 環境なので)
  - windows では **￥n**
### <u>書式指定</u>
    # 整数値(10進数 : 1, 23, -4, +5, )
    %d
    # 実数値(10進数 : 0.1, -5.3, 3.33, +8.1)
    %f
    # 実数値(10進数 : &f より長い桁が表示可能)
    %lf
    # 文字(ASCⅡコードで表示された文字列 / ' ' : 'A', 'b', '7')
    %c
    # 文字列(文字列をそのまま表示 / " " : "ABC", "山田太郎")
    %s
- **char型**　＝　文字　＝　’　’　（S・クォーテーション）で囲む
- **文字列**　＝　文字列　＝　”　”（W・クォーテーション）で囲む
変数
### <u>data型</u>
- **char**　:　1バイトの符号付き整数(ASCⅡコードといった文字コードに使用)

- **int**　:　2またわ4バイトの符号付整数(コンパイラに依存)

- **double**　:　8バイトの倍精度浮動小数点実数
  - float の 2倍だから *double*

### <u>初期化</u>
    # 1. 宣言と同時
    int a = 7;

    # 2. 複数宣言・複数初期化 / 複数宣言・１つだけ初期化
    int a, b;
    int a=1, b=2;
    int a, b=-5;
1. 変数宣言時に値を代入(**初期化**)することができる
2. (コンマ)で区切る事により同時に複数の変数を宣言したり、**初期化**も可能
### *「 変数は必ず初期化して使用する 」というルールがある*
### <u>変数の初期化の位置</u>
    void main()
    {
        // 使用する変数の定義・宣言の位置
        int a, b = 1;
        double d = 0.1, e;
        ...

        // 処理実行
        printf("a=%d b=%d\n", a, b, a+b);
        ...

        // 処理実行後...
        int c; <- 処理を行なった後に変数は宣言できない
    }
- 必ず{ }の先頭部分で行わなければならない
- 何んらかの処理が行われた後に記述すると error になる
### *C++ では大丈夫だが... C言語では上記のルールになっている*
### <u>C言語の変数の命名規則</u>
- 基本的には自由につける事が許されるが...
- 通常はアルファベット１文字か、その組み合わせの場合がほとんど
  - **半角英数 / 数字 / アンダーバー /**
    - *A ~ Z, a ~ z, 0 ~ 9, _*
  - **頭文字は数字はNG**
    - *1abc : NG*
  - **英文字の大小は別のモノとして扱われる**
    - *ABC, abc は違う変数として扱う*
    - *原則として小文字を使用した方が良い*
  - **規定されているC言語の予約語を使ってはいけない**
    - *仕様で使い方が決められている単語*
### <u>代入演算子</u>
    # = : aに値を代入
    a = 1;

    # += : aに値を加算して代入(a=a+1)
    a += 1;

    # -= : aに値を減算して代入(a=a-1)
    a -= 1;

    # *= : aに値を乗算して代入(a=a*1)
    a *= 1;

    # /= : aに値を除算して代入(a=a/1)
    a /= 1;

    # %= : aに値を剰余算して代入(a=a%1)
    a %= 1;
### <u>Cast(キャスト)とdata型変換</u>
    int j2;
    double d2;

    i2 = (int)d2;
    e2 = (double)j2;
- **double型**の変数を**int型**に変換して代入（初期化）
- **int型**の変数を**double型**に変換して代入（初期化）
  - *省略する事もできるが、基本は記述すること*
## **2. 条件分岐**
### <u>順次処理</u>
- 記述された様々な処理を、その順番どうりに事項するだけのモノ
### <u>分岐処理</u>
- ある条件で処理の流れが変わる処理　=　**分岐処理**
- 記述する為の命令として　->　**if,　swithc**
### <u>論理式との組み合わせ</u>
- *&& ( 論理責 : and )*　->　**A　かつ　B**
  - if( 条件式1　&&　条件式2 )　->　`条件式1と2が両方成り立つ`

- *|| ( 論理和 : or )*　->　**A　またわ　B**
  - if( 条件式1　||　条件式2 )　->　`条件式1か2どちらかが成り立つ`

- *! ( 否定 : not )*　->　**A　ではない**
  - if( !( 条件式1 ) )　->　`条件式1が成り立たない`
## **3. 繰り返し処理**
- 同じような処理を繰り返すこと(loop)
  - *for文,　while文,　do ~ while文*
### <u>インクリメント・デクリメント</u>
    # インクリメント(後置:こうち) : 変数値を１増加させる
    i++　->　i = i + 1

    # インクリメント(前置:ぜんち) : 変数値を１増加させる
    ++i　->　i + = 1

    # デクリメント(後置:こうち) : 変数値１減少させる
    i--　->　i = i - 1

    # デクリメント(前置:ぜんち) : 変数値１減少させる
    --i　->　i - = 1
※ 今ではどちらでも意味は同じ
## **4. 配列変数**
### <u>配列変数</u>
- **配列**は変数の箱が連なったもの

- 連なった箱１つ１つを「 **要素** 」という

- **複数のデータを扱う**ために必要

- 他所には一意の数( **添字** )がついている
### <u>文字列と配列</u>
- 配列変数は基本的にどのような型の変数でも利用可能

- 中でも特殊なのが　**char型**　の配列

- C言語には文字列を　**char型 の配列変数として扱う仕組み**があり、そのために様々な関数が用意されている
  - *C言語には文字列の方は無い*
### <u>文字列とNULL文字</u>
- char型の変数の成分には、それぞれ文字列のコードが入っている
  - *ASCⅡコードといった文字コード*

- 文字列の最後には、必ず　**\0**　(バックスラッシュ0)が入っている
  - **NULL文字**という
  - *配列の終わりを宣言する役目がある*
  - windows の場合は　->　**￥０**

- 値としては 0 に等しいが、文字として使用する場合は特に上記のように呼ぶ

- 配列変数に文字列を作る場合は、最低限　**文字列 + 1**　の成分が必要
  - 配列の途中に　**\0**　があればそこで終了
## **5. 関数の作り方**
### <u>関数</u>
- *特定の処理をまとめたもの*
  - **関数名**　関数の名前
  - **引数**　関数に与える **paramertor(入力)**
  - **戻り値**　関数により得られる結果 **return(結果)**
### <u>prototype 宣言</u>
- *呼び出す関数の型をあらかじめ予告しておく*
  - main() {} 関数より前に先頭行に記述
  - 型を決めておく事によって、その後に様々な場所で使用できる
### <u>void ( ヴォイド )</u>
- *関数の戻り値が無いという事を意味している*
  - これらの関数は戻り値を持たない
  - **return** を省略できる
### <u>local変数, global変数</u>
- *関数内で定義*　->　**local変数**
  - 関数内のみで使用できる
  - 関数の引数もlocal変数扱いとなる

- *porgram の先頭で定義*　->　**global変数**
  - どこでも呼び出して使用できる
  - １つ変数を変えたら全て変わってしまうので使用の場合はそこを加味する

  - *global変数にはなるべく使わない方が良いとされている*
      - セキュリティ観点でもリスクがある

  - *メモリを消費する -> program が終了するまでメモリが確保される*
      - local 変数 -> localの処理が終われば解放される
### <u>変数のスコープ</u>
- **変数の有効範囲**(スコープ)の違いは、定義されている場所に依存する
  - **global変数**　->　**どこでも使用可能**
    - *program 全体で一意の名前でなければいけない(重複は許されない)*

  - **local変数**　->　**定義された関数内だけ**
    - *定義されている関数が別の場所であれば同じ名前でも構わない*
## **6. file分割**
- 実用的な program は大規模
- file の分割は必ず必要になってくる
- 分割の仕方は program 機能によって様々
### <u>header file, source file</u>
- **header file**
  - 拡張子　`.h`
  - プリプロセッサーやマクロの定義
  - program の先頭部分に来るべき情報
    - *main program の前に必ず読み込まれるモノ*
    - *global変数, prototype宣言*

- **source file**
  - 拡張子　`.c`
  - program や function の定義に使用
### <u>2重 include 防止</u>
    #ifndef _(大文字で記述したfile名)_H_
    #define _(大文字で記述したfile名)_H_

    プロトタイプ宣言;
    プロトタイプ宣言;

    #endif // _(大文字で記述したfile名)_H_
- **#ifndef,　#define,　#endif**
  - **マクロ**　と言い C言語そのものの文法とは無関係
  - *compile に指令を与えるもの*

- **#ifndef ~ #endif**
  - 横に定義されているモノ : _〇〇_H_ がもし定義されていなかったら、#endif までの中に含まれている program を実行する

- **#define**
  - 定義をする : _〇〇_H_　を定義する
  - file名は絶対被らないので、C言語ではこういう風にしましょうという文化がある

- <u>上記の性質を利用して **2重 include** の防止をしている</u>

> 最近の compile は上記のような事をやらなくてもいいようにできているが...
> C言語は古めの source code などもメンテナンスする場合などもある
> 2重 include 防止をしないと上手く program が動かない事がある
### <u>#include の使い分け</u>
- **#include "・・・ "**
  - user 定義関数の include
  - 対応する `.c` fileがある場合
- **#include <・・・>**
  - 関数の定義の部分がすでに compile されているモノ
  - `.lib` fileとしてすでに source code が compile 済
  - `stdio.h` は **標準ライブラリ** と呼ばれるものを使用する時に用いる
    - *printf( ) etc...*
### <u>extern 修飾子</u>
    # 例）
    extern int 〇〇;
- **extern**
  - global変数は、複数の source file (.c file) で使用するが、定義はどちらか1箇所にしか記述できない。このような時に用いる
  - extern 英語で「 外に 」を意味する。この宣言が記述されている他の file にある事を意味する
## **7. 数値の扱い**
### <u>乱数</u>
- 乱数とは出鱈目な数値
- game のサイコロ, カードシャッフルするなどといった処理には乱数が欠かせない
  - **srand( )**　->　*srand(unsigned seed)*
    - rand で発生させる乱数を系列を変更, 初期化
      - `srand((unsigned)time(NULL))`

  - **rand( )**　->　*rand( )*
    - 0 ~ RAND_MAX の間の擬似乱数を返す(RAND_MAXは処理系依存)
      - `rand( ) % 10 + 1` : 1 ~ 10 までの乱数
      - *rand(　) % n+1*　:　1 ~ n までの乱数を取得
      - *rand(　) % (n+1)*　:　0 ~ n までの乱数を取得

  - **time( )**　->　*time_t time(time_t *timer);*
    - 1970年1月1日の 00:00:00 から現在までの経過時間を秒単位で取得する
      - `time(NULL)`
    - **srand で乱数を生成する時によく使用する**
### <u>三角関数</u>
- sin,　cos, tan, 数学でいう **三角関数**
  - **tan( )**　->　*tan( double rad );*
    - ( )に指定したラジアンを入れると **tan** が得られる
      - `double a = tan(2*3.14)`

  - **sin( )**　->　*sin( double rad );*
    - ( )に指定したラジアンを入れると **sin** が得られる
      - `double a = sin(2*3.14)`

  - **cos( )**　->　*cos( double rad );*
    - ( )に指定したラジアンを入れると **cos** が得られる
      - `double a = cos(2*3.14)`
- *角度をラジアンで入力しなければならない*
  - 2π　=　180.0度
### <u>rad (ラジアン)</u>
- 角度を 0 ~ 360度までで測るやり方を　**度数法(どすうほう)** という
- rad(ラジアン)で角度を指定する方法を　**弧度法(こどうほう)**　という
- rad(ラジアン)という考え方は、180度を　**π (パイ)**　rad(ラジアン)という考えるやり方
- 一般の角度(45°, 90° etc...)をrad(ラジアン)に変換するには、180度で割りそこに円周率を掛ける必要がある
### <u>定数の設定</u>
- **#define マクロ**
  - 定数を定義するのにも用いる事ができる
    - `#define PI 3.14`
- このようにすれば **PI** という文字列が出てくれば、この source file の中では 3.14 として扱う事ができる
  - *定数定義は基本的に大文字*
### <u>その他の数学関数</u>
- **abs( )**　->　*abs(int n);*
  - 与えられた整数の絶対値を求める
    - `int n = abs(-10)`

- **fabs( )**　->　*fabs(double d);*
  - 与えられた実数の絶対値を求める
    - `double d = abs(-3.1)`

- **pow( )**　->　*pow(double x, double y);*
  - x の y乗を求める
    - `double d = pow(3.0, 2.0)`

- **sqrt( )**　->　*sqrt(double d);*
  - 与えられた実数の平方根を求める
    - `double d = sqrt(25.0)`
### <u>bit演算</u>
- **<<**
  - 左シフト。指定されたbit数分、数値を左シフト
    - `00001111　<<　->　00011110　(1bit左シフト)`

- **>>**
  - 右シフト。指定されたbit数分、数値を右シフト
    - `00001111　>>　->　00000111　(1bit右シフト)`

- **|**
  - 論理和 ( OR演算 )。二つの数値の論理和をとる
    - `00001111　|　11111111　->　11111111`

- **&**
  - 論理積 ( AND演算 )。二つの数値の論理積をとる
    - `00001111　&　11111111　->　00001111`

- **~**
  - 否定演算 ( NOT演算 )。入力された1なら0に、0なら1に反転
    - `~00001111　->　11110000`
## **8. file write & read**
- text`.txt`　file,　binary`.bin`　file が存在する

| file種類 |                内容                |              例               |
| :------: | :--------------------------------: | :---------------------------: |
|   text   |          文字として読める          | .txt<br>.c<br>/html<br>...ect |
|  binary  | 文字として読めないdata(画像・音声) |    .png<br>/wav<br>...ect     |



### **<u>fopen( )</u>**

|   関数   |          書式          |                        意味                        |               使用例                |
| :------: | :--------------------: | :------------------------------------------------: | :---------------------------------: |
| fopen( ) | fopen(file名, モード); | fileを指定したモードで開く<br>戻り値がfile pointer | FILE* fp = open("sample.tex", "w"); |


### **<u>fopen( )関数モード</u>**

|  モード   |                        機能                        | fileが存在しない時 |
| :-------: | :------------------------------------------------: | :----------------: |
|     r     |                text data の読み込み                |    error になる    |
|     w     |                text data の書き込み                |    file新規作成    |
|     a     |               binary data の書き込み               |    file新規作成    |
|    r+     |  text data 更新モードで開く<br>書き込み・読み込み  |    error になる    |
|    w+     |  text data 更新モードで開く<br>書き込み・読み込み  |    file新規作成    |
|    a+     | binary data 更新モードで開く<br>書き込み・読み込み |    file新規作成    |
|    rb     |               binay data の読み込み                |    error になる    |
|    wb     |               binary data の書き込み               |    file新規作成    |
|    ab     |             binary data の追加書き込み             |    file新規作成    |
| rb+ / r+b | binary data 更新モードで開く<br>読み込み・書き込み |    errorになる     |
| wb+ / w+b | binary data 更新モードで開く<br>読み込み・書き込み |    file新規作成    |
| ab+ / a+b | binary data 更新モードで開く<br>読み込み・書き込み |    file新規作成    |


### **<u>file write</u>**

|    関数    |                      書式                       |          意味          |          使用例          |
| :--------: | :---------------------------------------------: | :--------------------: | :----------------------: |
| fprintf( ) | fprintf(file pointer, 書き込み文字列, 変数...); | fileを文字列に書き込む | fprintf(fp, "no=%d", i); |


### **<u>file close</u>**

|   関数   |         書式          |                  意味                  |   使用例    |
| :------: | :-------------------: | :------------------------------------: | :---------: |
| close( ) | fclose(file pointer); | 指定した file pointer の file を閉じる | fclose(fp); |


### **<u>text file 読み込み</u>**
- *1行ごとの file の読み込み*

|   関数   |                    書式                    |                    意味                    |      使用例       |
| :------: | :----------------------------------------: | :----------------------------------------: | :---------------: |
| fgets( ) | fgets(文字列, 文字列サイズ, file pointer); | 指定した size の文字列を file から読み込む | fgets(s, 10, fp); |


- *1文字ごとの file の読み込み*

|   関数   |         書式         |                                  意味                                   |  使用例   |
| :------: | :------------------: | :---------------------------------------------------------------------: | :-------: |
| fgetc( ) | fgets(file pointer); | 指定したtext file から１文字読み込む<br>戻り値が文字コード<br>EOFが終了 | fgec(fp); |



### **<u>binary file 読み込み</u>**

|   関数    |                       書式                        |          意味          |                    使用例                    |
| :-------: | :-----------------------------------------------: | :--------------------: | :------------------------------------------: |
| fwrite( ) | fwrite(data, dataのbyte長, data数, file pointer); | binary data の書き込み | fwrite(data, sizeof(int), sizeof(data), fp); |
| fread( )  | fread(data, dataのbyte長, data数, file pointer);  | binary data の読み込み | fread(data, sizeof(int), sizeof(data), fp);  |


### **<u>file 読み出しの問題点</u>**
- file は書き込むことは比較的簡単だた...
  - **読み込む時には大きな問題がある**

    - `file size` が分からない



### **<u>fseed, ftell関数</u>**
- *`fseek`　関数及び　`ftell`　関数は file の位置を指定する関数*

|   関数   |                   書式                   |                  意味                   |          使用例          |
| :------: | :--------------------------------------: | :-------------------------------------: | :----------------------: |
| fseek( ) | fseek(file pointer, 移動byte, 開始位置); | fileを開始位置から,移動byte数を移動する | fseek(fp, 0L, SEEK_END); |
| ftell( ) |           ftell(file pointer);           |    現在のfile位置の値をbyte数で返す     |        ftell(fp);        |
  - fseek( ) 関数を使用して最後まで file を読み込んでから ftell( ) 関数を使用すると, file の大きさが取得できる


- *seek関数で用いられる開始位置*

| 開始位置の定数 |     意味      |
| :------------: | :-----------: |
|    SEEK_SET    |   file 先頭   |
|    SEEK_CUR    | file 現在位置 |
|    SEEK_END    |   file 終端   |

## **9. 複雑な file 分割**

### **<u>列挙型</u>**
    // 性別の定義
    enum GENDER{
      MALE,       // 男性（値は 0）
      FEMALE,     // 女性（値は 1）
    };
- 順序などの何らかの秩序を持つデータを定数として定義する時に利用できる
  - *頭から 1, 2, 3... ect と自動的に番号が割り振られる*

### **<u>static変数</u>**
- static がついた変数を　`静的変数`　という
- **限定された領域でだけ使える global 変数**

  - `外部から使用できない global 変数`
    - *data の隠蔽*

  - *同一 file, 同一 function 内のみに限定*
  - *外部から操作する事はできない*









