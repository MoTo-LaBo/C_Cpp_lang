# C++言語　基礎入門
## **1. 名前空間 (namespace)**
- *C++ は C言語機能をそのまま受け継ぎ拡張したものなので*
  - **C言語と同じく　printf( ) 関数を用いる事ができる**

- 今回は **C++** 習得の為　`C++`　独自の表現方法を用いる

### **<u>header と iostream</u>**

- `#include`
  - *C言語同様 ( header file を読み込む時に用いる宣言 )*

- `iostream`
  - *header file だが **C++** の場合のモノであり　`.h`　は必要ない*
  - C言語の header file と一線を画すために　`head`　と呼ばれる

- **C++ の場合は head を読み込むことより, class を利用できるようになった**

### **<u>名前空間</u>**
- `using namespace`
  - *指定された**名前空間**を使うことを意味している*
  - 名前空間とは C言語には存在せず, C++ から用いられるようになった重要な概念

### **<u>cout</u>**
- porintf( ) 関数と同じような動きをするものとして　`cout`　が用意されている
- cout は C言語で用いる関数のようなモノではない

  - **見た目は似ているが実は　`object(オブジェクト)`　と呼ばれるモノで,特に標準入出力の出力をつかさどる**

- C++ の入出力 stream では　`>>`　及び　`<<`　を用いる事により, stream と呼ばれる対象に対する data のやりとり(流し込む様に)を行う
- `endl`　（エンドエル）改行を表す

### **<u>namespace(名前空間)とは? ①</u>**
- C++ と C言語の違いの一つにC++は, あらかじめ `大規模開発` を意識して作られた言語

  - *大規模開発 = 多数の人間が1つのソフトAppを開発すること*
  - *その場合に問題になってくるのが名前の **重複***

    - 一つの単語が変数名として使用されたら,他の開発者は使用できなくなり大変不便になる

### **<u>上記の改善の為の namespace ②</u>**

- `namespace (名前空間)`　という概念を用意

  - **namespace が違えば, 同じ名前を用いても良いというルールができた**
    - *今でいう仮想環境的なモノに近い*

### **<u>namespace の利用 ①</u>**
    // 名前空間の利用：定義
    using namespace (名前空間名);
- user が独自に定義するモノと, もともと C++に備わっているモノがある
- 後者のモノを　`標準名前空間`　と呼び,　`std`　と表記する

  - *cout などは, この　**標準名前空間**　で利用可能*

### **<u>namespace の利用 ②</u>**
    // 名前空間利用 : 定義
    (名前空間)::(変数名・クラス名など)
- 上記の方法だと　`using`　を使う必要はない

### **<u>console からの入力</u>**
- `cin`　も標準名前空間に含まれるものの一つ
  - C言語であれば, scanf( )関数に相当する処理

### **<u>stream の概念 ①</u>**
- `cout`　や　`cin`　は, 単純に C言語の printf( ), scanf( ) 関数の代わりと思われるが実は違う

  - *これらは　stream　と呼ばれるものに対して, data（数値や文字列など）を送り込んだり, 逆に受け取ったりするモノ*
  - stream は英語で *渓流* などを表す言葉　**流れ**　と言う意味で用いられる

- **<u>と言うことは...</u>**
  - *`cin`　や　`cout`　はその　**流れ**　から data を受け取ったり,送ったりするモノ*
  - 不等号はその向き(流れを表す)

    - **stream　->　console**
    - **stream　->　file system**

> これにより, file への読み書き, consoleからの入出力の処理がほとんど同じような記述で行う事ができる

### **<u>string と文字列</u>**
- C++ では文字列の操作を行う　`string`　という　`class`　が存在する

    - `string`　を　`cin`　及び　`cout`　と合わせて使うと便利

### **<u>string と演算子</u>**
- head で　`string`　を include
  - *C言語の strig.h とは違うので注意*

- 値への代入は **＝　（イコール）** 演算を用いておこう事ができる
- **＋（プラス）** 演算子を用いて, 文字列同士の結合が可能
- *C言語とは違い簡単に文字列操作ができるのが **C++** の特徴*
## **2. Class (クラス)**
- C++ 言語における class は, C言語の構造体とよく似ている
  - 構造体は, 複数の変数を一つにまとめたもの

- *class は メンバとして変数と関数の両方を含める事ができる構造を持っている*
  - 変数を　＝　`メンバ変数`
  - 関数を　＝　`メンバ関数`

### **<u>class の宣言</u>**

    class CSample {
    public:
        void set(int num);    // m_num に値を設定する
        int get();            // m_num の値を取得する
    private:
        int m_num;
    };

- 最初に付け　`class`　は,　`class宣言`　をすることを意味する

- 構造体の **struct** と同じ様な役割を果たしている

- **CSample**　->　class名

### **<u>メンバ変数・メンバ関数</u>**

- 構造体の場合と同様, class の構成要素は　`メンバ`　と呼ばれる

- 普通の変数宣言や関数プロトタイプと同じ記述の仕方

- メンバ変数として, **m_num** が, メンバ関数として **function( )** が定義されている

- 特にメンバ関数の事を　`method(メソッド)`　とも呼ぶ

### **<u>アクセス修飾子</u>**

- `public`　`private`　というキーワードは, **アクセス修飾子** と言う

### **<u>class定義とobject生成</u>**

- class を利用するには class 変数を宣言
  - 構造体変数を宣言するのと同じ

- **インスタンス**　とか　**object**　などと言う

### **<u>インスタンスとは? ①</u>**

- class のインスタンス生成
  - インスタンス化　->　実体化　->　classを実体化する

- class はそのままでは単なる **型** に過ぎない
  - `使用するには実体化が必要`

- メンバ変数・関数を使用する時(アクセスする時)は, 構造体と同じで　`.(ドット演算子)`　を使用する

- インスタンスへの pointer を経由するときは　`アロー演算子(->)`　を使う

### **<u>class の命名規則</u>**

- 通常 head file名は class の名前と対応してつけられるのが一般的

  - *head file であることからC言語と同じ 2重 include 防止を記述*
  - **#ifndef,　#define,　#endif**　マクロで　**２重 include の防止**
  - 何度も **include** される為の処理

### **<u>メンバ関数</u>**

- C言語のプロトタイプ宣言にあたる部分は, C言語のメンバ関数の宣言の中に記述
  - 実装は対応する　`.cpp`　fileの中

- 関数名だけでは何の class メンバ関数なのか分からないので,関数名の頭に class名をつけ　`::`　ではさむ
    - **Csample::set**　の様に記述
    - CSample class の setメンバ関数の事だとわかる


|       宣言        |         実装          |
| :---------------: | :-------------------: |
| void set(int num) | CSample::set(int num) |
|     int get()     |  int CSample::get()   |

## **3. アクセス指定子**
- `public`
  - *全ての範囲から呼び出しが可能・読み出し可能*

- `private`
  - *同一 class または同一インスタンス無いでのアクセス可能*

- `protected`
  - *同一 class または同一インスタンス及び, sub class 及び, インスタンス内でのみアクセス可能*

### **<u>カプセル化と access method</u>**
- **カプセル化(隠蔽)**
  - メンバへアクセスをその class のメンバ関数からだけしかできない様に制限すること

  - 一部の例外を除き C++ では　`カプセル化して隠蔽する`　ことが一般的

  - メンバ変数の値を設定したり,取得したりするメンバ変数が必要になってくる

    - 上記を　`access method`　と言う

- **set( ) : セッター**
    - *メンバ変数に書き込みを行う関数*

- **get( ) : ゲッター**
  - *メンバ変数に読み込みを行う関数*

## **4. 生成と消去**
- *メンバ関数の特殊 method*

- `constructor`

  - *class を instance化した時に自動的に1度だけ呼び出される*

  - *主に初期化処理を行う*

  - **戻り値がないので型を定義する必要はない**

- `destructor`

  - *class の instance が解放される時に自動で１度だけ呼び出される*

  - *class名の先頭に　**~ (チルダ)**　をつけたもの*

  - *終了処理を行う*

### **<u>instance の生成とタイミング</u>**
- 画像 data など大量の memory を消費する instance の場合は, **生成と消去**　のタイミングが制御できないと不便

- `new演算子`

  ```
  new constructor名( )
  ```

- `delete演算子`

  ```
  delete instance名
  ```

### **<u>C言語 malloc, free を使用しない理由</u>**

- **C++では malloc( )関数 (calloc, realloc も同様) 及び free( )関数を使わない**

  - `malloc() 関数では　constructor　を呼び出す事ができない`

  - `free() 関数では　destructor　を呼び出す事ができない`

  - *なので memory 生成及び削除は　`new`　と　`delete`　が用いられる*

### **<u>配列の生成</u>**
- **delete[ ]** を使用する

## **5. static variable (静的メンバ)**

- **instance を生成する事なく利用できるメンバ変数・関数**

  - instance 生成が必要なメンバを　**instance メンバ**　と呼び

## **6. 継承 inheritance**
- object指向言語の重要な特性　->　**継承(inheritance : インヘリタンス)**
  - *あるメンバ class を他の class に引き継ぐ(継承させる)という効果がある*

### **<u>親 class . 子 class</u>**

- **親 class または super class**

- **子 class または sub class**

### **<u>実装例</u>**
  ```
  class 子class : public 親class
  ```

### **<u>sub の costructor & destructor</u>**
- *sub class の constructor と destructor の挙動*

- `constructor`
  - **親class**　->　**親constructor 実行**　->　**子class**　->　**子constructor 実行**


- `destructor`
  - **子class**　->　**子destructor 実行**　->　**親class**　->　**親destructor 実行**

### **<u>protected メンバ</u>**

- `protected`

  - **privateメンバ**　同様, class外からのアクセスはできない

  - **protectedメンバ**は, 子 class から見れば　**public**　同様に, class の外から見れば　**private**　同様に振る舞う

  - sub class のみに access を許すメンバには　`protected`　修飾子を付ける

### **<u>単一継承と多重継承</u>**
- 親class が一つしかないような継承の仕方を　`単一継承`

- C++ では一つの class に複数の親class を設定することができる

  - 上記を　**多重継承**　と言う

## **7. polymorphism(ポリモーフィズム)**
- **override (オーバーライド)** , **overload (オーバーロード)** を総称して　`Polymorphism(ポリモーフィズム)`　と言う

  - **多態性**,　**多様性**

  - メンバ関数の名前が統一される事により, 名前を覚えることや, 記述ミスを減らせる

### **<u>Overload</u>**
- constructor を含め, 全てのメンバ変数, 引数, 及び戻り値が違っていれば, **同じ名前**　のついた複数の method を定義する事ができる

- 同様の事が constructor にも言える
  - 引数が付いていないものを　**default constructor**　と言う

  - 普通は default constructor を省略できる

  - *1つでも引数が付いている constructor がある場合は*
    - **defaul constructor が省略できないので注意する**
### **<u>Override</u>**
- 親 class の method が上書きされる

## **8. C言語との違い**
- **引数の参照渡し**
  - C言語の **値渡し** と　**pointer渡し**　に加えて　**参照渡し** と呼ばれる方法もプラスされる

### **<u>pointer渡し・参照渡しの違い</u>**

|             |    引数として渡す値     |     関数定義:例     |                      関数呼び出し:例                      |
| :---------: | :---------------------: | :-----------------: | :-------------------------------------------------------: |
| pointer渡し | 変数のアドレスかpointer | void func1(int* a) | func1(&a); // a:int型変数名<br>func1(p);//p:int型 pointer |
|  参照渡し   |        変数の値         | void func2(int& n)  |   func2(a);//a:int型変数<br>func2(*p);//p:int型 pointer   |

## **9. class間の相互参照**
### **<u>#includeの問題</u>**
- *C++で実用的な program を作成すようとする場合に避けて通れない問題*
  - **class相互参照**

- 相互で利用したい class があった場合に, お互いが **include**　する事により, **#include 処理が終わらない**　という事が起こってしまう
  - *build error になる*

### **<u>const修飾子</u>**
- 引数の状態が変更されないことを保証する事ができる

  - const を付ける事によって, compile は最適化しやすくなり処理速度の向上, memory を効率的に使用することが可能であるとされる

  - 変数の使用方法に制限をつけることで, programing の誤りを未然に防げる

### **<u>const修飾子の使用例</u>**

|     使用場所     |          使用例           |         意味         |                  解説                   |
| :--------------: | :-----------------------: | :------------------: | :-------------------------------------: |
|     変数の前     |    const int a = 100;     |      定数の定義      |       定数として値を変更できない        |
| メンバ関数の引数 | void setNum(const int a); |    引数の変更不可    |    関数内では,引数の状態が変化しない    |
| メンバ関数の後ろ |    intgetNum() const;     | メンバ変数の変更不可 | 関数内では,メンバ変数の状態が変化しない |

## **10. template と STL**
- **ジェネリック programing**
  - *演算子が同じであれば, 型がなんであっても使えるようにする*

  - その仕組みを使える様にするのが **template**

    - 関数(function)を用いる **template関数**

    - クラス(class)を用いる **template class**

### **<u>inline 修飾子</u>**
- **inline**
  - *inline という修飾子が先頭に付くと, その関数は compile 時に `inline に展開`　される事になる。という宣言*

  - inline 宣言されていない普通の関数は compile 後, アンセンブラの中で program の流れの中と別の部分に記録され, 必要な時だけ呼び出される

  - **inline の場合は上記の処理部分が, 直接埋め込まれる為に処理の呼び出しなどのオーバーヘッドが少なくなり,　処理速度が向上する**

### **<u>inline のメリット・デメリット</u>**
- 頻繁に使用されるうえに, 関数の処理が長い場合には source code が大きくなりすぎてしまう

- compile に依存する部分が多く, どのような code に使用しても必ず効果があるわけではない

- **set ( セッター ), get ( ゲッター )**　のような case の処理は, オーバーヘッドが少ないうえに, 頻繁に使用される事から, 一般的に　**const**　などと併用して　**inline**　を用いると　`C++ program パフォーマンス`　を向上させると言われている

## **11. STL①**

### **<u>STLとは？</u>**
- **STL ( Standard Template Library )**
  - template を用いた C++ の library であり, program の上で必要な様々な data形式を, 煩雑な記述なしに誰でも簡単に利用できる

### **<u>配列とSTL</u>**
- **vector,　list,　map**　->　配列の概念を拡張したもの

  - *size を意識せずに使える配列*

### **<u>vector</u>**
- **動的配列**
  - size を意識しないで使用できる

### **<u>vector method</u>**

|    関数名    |               意味               |
| :----------: | :------------------------------: |
| push_back( ) |            要素の追加            |
|   clear( )   |           要素のクリア           |
|   size( )    |      配列の大きさを得る関数      |
| capacity( )  | 動的配列に追加できる要素の許容量 |
|   empty( )   |     要素が空かどうかを調べる     |

### **<u>List</u>**
- **listは任意の位置に自由に data を挿入できる**

### **<u>iterator</u>**
- **list には　vector や配列のような index を使う事ができない**
  - なので　`iterator`　を使用する

### **<u>vector と List の共通点と違う点</u>**
- vector も list と同様に iterator を使用できる

- **remove** は　**list**　の中から指定された　iterator値をしてするとそれを除去してくれる

- **remove**　method　は　**vector**　には存在しない

### **<u>List method</u>**

|    関数名     |         意味         |
| :-----------: | :------------------: |
| push_front( ) | 先頭に要素を追加する |
| push_back( )  | 末尾に要素を追加する |
| pop_front( )  | 先頭の要素を削除する |
|  pop_back( )  | 末尾の要素を削除する |
|   insert( )   |    要素を挿入する    |
|   erase( )    |    要素を削除する    |
|   clear( )    |   全要素を削除する   |

## **12. STL②**

