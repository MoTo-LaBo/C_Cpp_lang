# Address と Pointer
### **<u>変数のアドレス</u>**

- 変数はコンピューターのメモリの中にあるため **address** が存在する
  - **a** 変数　->　**&a** と記述
    - `変数アドレスを取得することができる`

- <u>これにより変数の値がメモリ中のどこに存在するかを知る事ができる</u>

### **<u>sizeof 演算子</u>**
- **sizeof(サイズオブ)** 演算子は、変数や型のメモリのサイズを取得する演算子
- ( ) の中に変数や型を記述すれば size を byte単位で取得可能
- *各変数はメモリ空間に適切な大きさで割り振られている*
  - *1byte, 4byte, 8byte... etc*

### **<u>pointer</u>**
- 言語には address を入れる事を前提とした変数が存在する
- 先頭に　**＊**　(アスタリスク)をつける事でその変数が **pointer 変数** であることを示す
  - `pointer　＝　場所を指すモノ　＝　address`

### **<u>通常変数・pointer 比較(int型の場合)</u>**
- *宣言*
  - 通常変数　->　`int a;`
  - pointer　->　`int *p;`
    - *pointer 変数は、変数の先頭に **＊** をつける*

- *値*
  - 通常変数　->　`a`
  - pointer　->　`*p;`
    - *pointer 変数で値を示すには、変数の先頭に **＊** をつける必要がある*

- *address*
  - 通常変数　->　`&a`
  - pointer　->　`p`
    - *通常変数は値を入れるが前提だが、pointer 変数は **address** を入れる*

- *宣言*
  - 通常変数　->　`int a;`
  - pointer　->　`int *p;`
    - *pointer 変数は、変数の先頭に **＊** をつける*

### **<u>NULLによる初期化</u>**
- pointer 変数に　**NULL(ヌル)**　を入れて初期化
- NULL は, C言語で標準的に用いられる定数で,数値で言えば　**0**　を意味する
- 通常の　**pointer 変数は NULL で初期化する**　という習慣になっている
#### pointer 初期化(定義)
    int* p = NULL;
### <u>NULL pointer への Acssce</u>
- 初期化したまま何らかの変数の address を設定しなかった場合...
  - **compile error は出ないが 実行時 error が出て強制終了する**
## **<u>pointer に変数の address を代入</u>**
- *すでに存在する変数を指し示す*
  - **指し示した変数になりすます**

    | 番号  |   処理    |      処理内容       |            意味             |   a   |   b   |  *p   |
    | :---: | :-------: | :-----------------: | :-------------------------: | :---: | :---: | :---: |
    |   1   |  p = &a;  | pにaのadrressを代入 |    *pはaと同じモノになる    |  100  |  200  |  100  |
    |   2   | *p = 300; |    *pに300を代入    |   *pはaに等しいモノになる   |  300  |  200  |  300  |
    |   3   |  p = &b;  | pにbのadrressを代入 |    *pはbと同じモノになる    |  100  |  200  |  200  |
    |   4   | p = 400;  |    *pに400を代入    | *pはbと等しいので,bが変わる |  100  |  200  |  100  |

    - **<u>状況によって adrress が指し示したモノになりすます事ができる</u>**

### **<u>注意点</u>**
- pointer に変数 address を設定する時には,原則的に同じ型の pointer 変数でする
- **int a**　であれば　**int ＊p**,　**double d**　であれば　**double ＊pd**　といったように, 対応する型を合わせるようにする
> 型が違くても *compile error* にはならないが　`実行時に致命的な error`　になる可能性がある

### **<u>pointer と関数</u>**
- 引数に pointer を与える事により address を与えた変数の値を変更する事ができる

  - *通常, function(関数)での処理では, <u>変数は１つの戻り値しか返す事ができない</u>*

> **pointer を渡す事により実質複数の戻り値を持つ, もしくは引数を戻り値と同じように扱う事ができる関数を作成できる**


# Array と Pointer
- pointer が他の変数に「 なりすます 」ことにより, 一つの pointer で様々な値を設定, 取得ができる
- この特性は　**配列変数**　に適用するとより効果が発揮できる

### **<u>pointer と array の関係性①</u>**

| 配列変数 | 配列変数add | 該当pointer | pointer変数の値 |
| :------: | :---------: | :---------: | :-------------: |
|  ar1[0]  |   &ar1[0]   |     p1      |       *p1       |
|  ar1[1]  |   &ar1[1]   |    p1+1     |     *(p1+1)     |
|  ar1[2]  |   &ar1[2]   |    p1+2     |     *(p1+2)     |
|  ar1[3]  |   &ar1[3]   |    p1+3     |     *(p1+3)     |
|  ar1[4]  |   &ar1[4]   |    p1+4     |     *(p1+4)     |

### **<u>pointer と array の関係性②</u>**

|             |        |        |      |        |        |
| ----------- | ------ | ------ | ---- | ------ | ------ |
| 配列        | a[0]   | a[1]   | a[2] | a[3]   | a[4]   |
| 該当pointer | p-2    | p-1    | p    | p+1    | p+2    |
| pointer変数 | *(p-2) | *(p-1) | *p   | *(p+1) | *(p+2) |
- *あまり使用しないが, 考え方としてこういう事もできる*

### **<u>pointerとしての配列変数</u>**
- 配列変数というのは pointer のある特殊な形
#### pointer へ address 代入
    # 例)
    p1 = d;
    p2 = d;
- 上記は配列変数　**d**　の先頭 address

  - `&d[0]`　**の値を代入するのと同じ処理である**

  - *配列変数は添え字がなければ pointer 変数と同じように使用できる*

  - 表記はできるものの, pointer 変数とは違って**他の変数のアドレスを取得する事はできない**

### **<u>値をインクリメント</u>**
    # p2 は &d[0] と同じ値をとる
    p2 = d;

    # インクリメント : ++ する事で &d[1] と同じ値
    p2++;

    # 更にインクリメント : ++ &d[2] と同じ値
    p2++;
- *値をインクリメントする事によって address を変えている*

## **動的な memory の生成**
- pointer を使用すれば, 必要な箇所で動的に memory を確保し, 必要がなくなったら破棄する事ができる
  - *自動で配列を生成できる**


- `malloc( )` (マロック)

  - memory を動的に確保する処理を行う関数
  - ( ) 内に確保した memory の大きさを byte 数で指定


- `free( )` (フリー)

  - memory を解放する関数
  - ( ) 内には, 確保した memory の address を持つ pointer を引数として与える

### 動的な memory 生成
    # 配列を生成
    p = (int*)malloc(sizeof(int)*10);

    # 解放
    free(p);

### **<u>C言語で用いられる memory func</u>**

| 関数名  |   読み方   |                                説明                                |
| :-----: | :--------: | :----------------------------------------------------------------: |
| malloc  |  マロック  |            引数で指定したbyte数だけ動的に memory を確保            |
| calloc  | キャロック | malloc と基本は同じだが, 生成された領域は全て 0 で初期化されている |
| realloc | リアロック |           一度確保された memory を違うサイズで確保し直す           |


### **<u>memory の 4領域</u>**

| 番号  |      名前      |                 説明                 |
| :---: | :------------: | :----------------------------------: |
|   ①   | プログラム領域 |  program (マシン語)が格納される場所  |
|   ②   |    静的領域    | global変数やstatic変数が置かれる領域 |
|   ③   |   ヒープ領域   |  動的に確保された memory を置く領域  |
|   ④   |  スタック領域  |     local変数などが置かれる領域      |

- **変数が確保される領域は ② ~ ④ の領域**
# String と Pointer

### **<u>文字列の結合とコピー</u>**

|   関数    |            書式             |                   意味                   |       使用例        |
| :-------: | :-------------------------: | :--------------------------------------: | :-----------------: |
| strcpy( ) | strcpy(char* s1, char* s2); | 右辺の文字列を左辺の文字列変数にcopyする | strcpy(s, "Hello);  |
| strcat( ) | strcat(char* s1, char* s2); |   右辺の文字列を左辺の文字列に追加する   | strcat(s, "World"); |


### **<u>文字列の長さ</u>**

|   関数    |       書式       |                       意味                        |          使用例          |
| :-------: | :--------------: | :-----------------------------------------------: | :----------------------: |
| strlen( ) | strlen(char* s); | ( )に文字列を与えると, 戻り値として長さが得られる | int l = strlen("Hello"); |
- **文字列の長さは char型の配列の　`0番`　の文字から, 最後の　`￥0`　に辿り着くまでに入っている文字数をさす**


### **<u>文字列の比較</u>**

|   関数    |            書式             |                           意味                           |            使用例            |
| :-------: | :-------------------------: | :------------------------------------------------------: | :--------------------------: |
| strcmp( ) | strcmp(char* s1, char* s2); | 文字列s1, s2が等しいと0,等しくなければそれ以外の値を返す | if(strcmp(s, "Hello") == 0); |


### **<u>文字列から数値への変換</u>**

|  関数   |      書式      |                  意味                  |          使用例          |
| :-----: | :------------: | :------------------------------------: | :----------------------: |
| atoi( ) | atoi(char* s); |  与えら得た文字列を整数(int)に変える   |   int n = atoi("100");   |
| atof( ) | atof(char* s); | 与えら得た文字列を実数(double)に変える | double d = atof("3.14"); |

### **<u>数値から文字列の変換</u>**
- **sprintf( ) 関数を使用**
  - printf( ) と同じ要領で文字列を作成できる非常に便利な関数


### **<u>文字列関数における注意点</u>**
- 文字列の配列の size が 10 しかないのに, それ以上の長さの文字列を代入する事はできない
- *このような場合は compile 時には error は出ないが, 実行時に system が異常終了するなどといった事が起こるので注意が必要*
# Structure (構造体)
- program がある程度複雑になってくると, 1つの概念に対して複数の変数が割り当てられる事がある
  - 例)
    - *学生番号, 名前, 年齢 を一つにまとめて学生の data base を作成*
- そういう時に用いられるのが　**構造体(struct)**
  - **構造体**　＝　**複数の変数を一まとめにする**

### **<u>構造 sample</u>**
    struct <構造体の名前> {
      int id;
      char name[256];
      int age;
    };

    # 構造体使用時
    struct <構造体名>;

  - **int id　＝　学生番号**
  - **char name　＝　名前**
  - **int age　＝　年齢**

- このような構造体の定義を　`構造体テンプレート`　という
- 構造体の中の変数を　`メンバ`　という
- `struct`　が構造体を表すキーワード, その後が構造体の名前になる **< 構造体の名前 >**　がくる
  - 構造体の名前は変数の命名規則と同じで任意につける事ができる
  - `{ }`　の中に一まとめにする変数を定義する
  - 最後は　`;(セミコロン)`　で終了

### **<u>typedef</u>**
    # 構造体名の変更
    typedef struct <構造体名> <構造体名２>;

    # 構造体使用時
    <構造体２> s;
- **`typedef`**　は既存の型に新しい名前（別名）を付ける為のキーワード
- 先頭に　`struct`　キーワードを付ける事なく構造体変数を定義することができる
- *現在は構造体使用時は　**typedef**　が通常使用になっている*

## **構造体の pointer**
- 通常構造体では, メンバに acssce するのに　`.`　(ドット)を用いるが...
- pointer は　`ー＞`　(アロー演算子)を用いる

- *構造体名 -> student_data*

|        |           通常の構造体           |             構造体 pointer             |
| :----: | :------------------------------: | :------------------------------------: |
|  定義  |        student_data data         |          student_data* pData           |
| メンバ | data.id<br>data.name<br>data.age | pData->id<br>pData->anem<br>pData->age |
|   値   |             data渡し             |              pointer渡し               |


### **<u>pointer渡し と data渡し</u>**
- `data渡し`
  - *値の変更を行なっても反映される事はない*
    - *address 自体が違うものである*
    - **copy data を渡しているので, 値が変更されても元の data には影響はない**

- `pointer渡し`
  - *値が変更されたら元の値も変更される*
    - **元の address を渡しているので,変更内容もそのまま反映される**

### **<u>data 私の問題点</u>**
- 構造体自体がdata size が大きなる傾向があり, 引数としてそのままの値を渡すと **スタック領域** を圧迫してしまったり, dataの copy という無駄な処理が起こる
- *pointer渡しであれば, 関数内の中で値の設定などができる*
