# Address と Pointer
### **<u>変数のアドレス</u>**

- 変数はコンピューターのメモリの中にあるため **address** が存在する
  - **a** 変数　->　**&a** と記述
    - `変数アドレスを取得することができる`

- <u>これにより変数の値がメモリ中のどこに存在するかを知る事ができる</u>

### **<u>sizeof 演算子</u>**
- **sizeof(サイズオブ)** 演算子は、変数や型のメモリのサイズを取得する演算子
- ( ) の中に変数や型を記述すれば size を byte単位で取得可能
- *各変数はメモリ空間に適切な大きさで割り振られている*
  - *1byte, 4byte, 8byte... etc*

### **<u>pointer</u>**
- 言語には address を入れる事を前提とした変数が存在する
- 先頭に　**＊**　(アスタリスク)をつける事でその変数が **pointer 変数** であることを示す
  - `pointer　＝　場所を指すモノ　＝　address`

### **<u>通常変数・pointer 比較(int型の場合)</u>**
- *宣言*
  - 通常変数　->　`int a;`
  - pointer　->　`int *p;`
    - *pointer 変数は、変数の先頭に **＊** をつける*

- *値*
  - 通常変数　->　`a`
  - pointer　->　`*p;`
    - *pointer 変数で値を示すには、変数の先頭に **＊** をつける必要がある*

- *address*
  - 通常変数　->　`&a`
  - pointer　->　`p`
    - *通常変数は値を入れるが前提だが、pointer 変数は **address** を入れる*

- *宣言*
  - 通常変数　->　`int a;`
  - pointer　->　`int *p;`
    - *pointer 変数は、変数の先頭に **＊** をつける*

### **<u>NULLによる初期化</u>**
- pointer 変数に　**NULL(ヌル)**　を入れて初期化
- NULL は, C言語で標準的に用いられる定数で,数値で言えば　**0**　を意味する
- 通常の　**pointer 変数は NULL で初期化する**　という習慣になっている
#### pointer 初期化(定義)
    int* p = NULL;
### <u>NULL pointer への Acssce</u>
- 初期化したまま何らかの変数の address を設定しなかった場合...
  - **compile error は出ないが 実行時 error が出て強制終了する**
## **<u>pointer に変数の address を代入</u>**
- *すでに存在する変数を指し示す*
  - **指し示した変数になりすます**

    | 番号  |   処理    |      処理内容       |            意味             |   a   |   b   |  *p   |
    | :---: | :-------: | :-----------------: | :-------------------------: | :---: | :---: | :---: |
    |   1   |  p = &a;  | pにaのadrressを代入 |    *pはaと同じモノになる    |  100  |  200  |  100  |
    |   2   | *p = 300; |    *pに300を代入    |   *pはaに等しいモノになる   |  300  |  200  |  300  |
    |   3   |  p = &b;  | pにbのadrressを代入 |    *pはbと同じモノになる    |  100  |  200  |  200  |
    |   4   | p = 400;  |    *pに400を代入    | *pはbと等しいので,bが変わる |  100  |  200  |  100  |

    - **<u>状況によって adrress が指し示したモノになりすます事ができる</u>**

### **<u>注意点</u>**
- pointer に変数 address を設定する時には,原則的に同じ型の pointer 変数でする
- **int a**　であれば　**int ＊p**,　**double d**　であれば　**double ＊pd**　といったように, 対応する型を合わせるようにする
> 型が違くても *compile error* にはならないが　`実行時に致命的な error`　になる可能性がある

### **<u>pointer と関数</u>**
- 引数に pointer を与える事により address を与えた変数の値を変更する事ができる

  - *通常, function(関数)での処理では, <u>変数は１つの戻り値しか返す事ができない</u>*

> **pointer を渡す事により実質複数の戻り値を持つ, もしくは引数を戻り値と同じように扱う事ができる関数を作成できる**


# Array と Pointer
- pointer が他の変数に「 なりすます 」ことにより, 一つの pointer で様々な値を設定, 取得ができる
- この特性は　**配列変数**　に適用するとより効果が発揮できる

### **<u>pointer と array の関係性①</u>**

| 配列変数 | 配列変数add | 該当pointer | pointer変数の値 |
| :------: | :---------: | :---------: | :-------------: |
|  ar1[0]  |   &ar1[0]   |     p1      |       *p1       |
|  ar1[1]  |   &ar1[1]   |    p1+1     |     *(p1+1)     |
|  ar1[2]  |   &ar1[2]   |    p1+2     |     *(p1+2)     |
|  ar1[3]  |   &ar1[3]   |    p1+3     |     *(p1+3)     |
|  ar1[4]  |   &ar1[4]   |    p1+4     |     *(p1+4)     |

### **<u>pointer と array の関係性②</u>**

|             |        |        |      |        |        |
| ----------- | ------ | ------ | ---- | ------ | ------ |
| 配列        | a[0]   | a[1]   | a[2] | a[3]   | a[4]   |
| 該当pointer | p-2    | p-1    | p    | p+1    | p+2    |
| pointer変数 | *(p-2) | *(p-1) | *p   | *(p+1) | *(p+2) |
- *あまり使用しないが, 考え方としてこういう事もできる*

### **<u>pointerとしての配列変数</u>**
- 配列変数というのは pointer のある特殊な形
#### pointer へ address 代入
    # 例)
    p1 = d;
    p2 = d;
- 上記は配列変数　**d**　の先頭 address

  - `&d[0]`　**の値を代入するのと同じ処理である**

  - *配列変数は添え字がなければ pointer 変数と同じように使用できる*

  - 表記はできるものの, pointer 変数とは違って**他の変数のアドレスを取得する事はできない**

### **<u>値をインクリメント</u>**
    # p2 は &d[0] と同じ値をとる
    p2 = d;

    # インクリメント : ++ する事で &d[1] と同じ値
    p2++;

    # 更にインクリメント : ++ &d[2] と同じ値
    p2++;
- *値をインクリメントする事によって address を変えている*

## **動的な memory の生成**
- pointer を使用すれば, 必要な箇所で動的に memory を確保し, 必要がなくなったら破棄する事ができる
  - *自動で配列を生成できる**


- `malloc( )` (マロック)

  - memory を動的に確保する処理を行う関数
  - ( ) 内に確保した memory の大きさを byte 数で指定


- `free( )` (フリー)

  - memory を解放する関数
  - ( ) 内には, 確保した memory の address を持つ pointer を引数として与える

### 動的な memory 生成
    # 配列を生成
    p = (int*)malloc(sizeof(int)*10);

    # 解放
    free(p);

### **<u>C言語で用いられる memory func</u>**

| 関数名  |   読み方   |                                説明                                |
| :-----: | :--------: | :----------------------------------------------------------------: |
| malloc  |  マロック  |            引数で指定したbyte数だけ動的に memory を確保            |
| calloc  | キャロック | malloc と基本は同じだが, 生成された領域は全て 0 で初期化されている |
| realloc | リアロック |           一度確保された memory を違うサイズで確保し直す           |


### **<u>memory の 4領域</u>**

| 番号  |      名前      |                 説明                 |
| :---: | :------------: | :----------------------------------: |
|   ①   | プログラム領域 |  program (マシン語)が格納される場所  |
|   ②   |    静的領域    | global変数やstatic変数が置かれる領域 |
|   ③   |   ヒープ領域   |  動的に確保された memory を置く領域  |
|   ④   |  スタック領域  |     local変数などが置かれる領域      |

- **変数が確保される領域は ② ~ ④ の領域**
# String と Pointer

### **<u>文字列の結合とコピー</u>**

|   関数    |            書式             |                   意味                   |       使用例        |
| :-------: | :-------------------------: | :--------------------------------------: | :-----------------: |
| strcpy( ) | strcpy(char* s1, char* s2); | 右辺の文字列を左辺の文字列変数にcopyする | strcpy(s, "Hello);  |
| strcat( ) | strcat(char* s1, char* s2); |   右辺の文字列を左辺の文字列に追加する   | strcat(s, "World"); |


### **<u>文字列の長さ</u>**

|   関数    |       書式       |                       意味                        |          使用例          |
| :-------: | :--------------: | :-----------------------------------------------: | :----------------------: |
| strlen( ) | strlen(char* s); | ( )に文字列を与えると, 戻り値として長さが得られる | int l = strlen("Hello"); |
- **文字列の長さは char型の配列の　`0番`　の文字から, 最後の　`￥0`　に辿り着くまでに入っている文字数をさす**


### **<u>文字列の比較</u>**

|   関数    |            書式             |                           意味                           |            使用例            |
| :-------: | :-------------------------: | :------------------------------------------------------: | :--------------------------: |
| strcmp( ) | strcmp(char* s1, char* s2); | 文字列s1, s2が等しいと0,等しくなければそれ以外の値を返す | if(strcmp(s, "Hello") == 0); |


### **<u>文字列から数値への変換</u>**

|  関数   |      書式      |                  意味                  |          使用例          |
| :-----: | :------------: | :------------------------------------: | :----------------------: |
| atoi( ) | atoi(char* s); |  与えら得た文字列を整数(int)に変える   |   int n = atoi("100");   |
| atof( ) | atof(char* s); | 与えら得た文字列を実数(double)に変える | double d = atof("3.14"); |

### **<u>数値から文字列の変換</u>**
- **sprintf( ) 関数を使用**
  - printf( ) と同じ要領で文字列を作成できる非常に便利な関数


### **<u>文字列関数における注意点</u>**
- 文字列の配列の size が 10 しかないのに, それ以上の長さの文字列を代入する事はできない
- *このような場合は compile 時には error は出ないが, 実行時に system が異常終了するなどといった事が起こるので注意が必要*



















